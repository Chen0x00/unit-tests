/*
 * This file was automatically generated by SmartUnit
 */

package sut.com.wanxin.uaa.domain;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Method;
import static org.smartunit.shaded.org.mockito.Mockito.*;
import org.smartunit.shaded.org.mockito.ArgumentMatchers;
import static org.smartunit.runtime.SmartAssertions.*;
import com.wanxin.uaa.domain.ClientDefaultAccessTokenConverter;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.SynchronousQueue;
import javax.swing.JLayeredPane;
import org.junit.runner.RunWith;
import org.smartunit.runtime.ExecutorServiceAnswer;
import org.smartunit.runtime.PrivateAccess;
import org.smartunit.runtime.SmartRunner;
import org.smartunit.runtime.SmartRunnerParameters;
import org.smartunit.runtime.TransactionTemplateAnswer;
import org.smartunit.runtime.ViolatedAssumptionAnswer;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;
import org.springframework.security.oauth2.provider.token.UserAuthenticationConverter;

@RunWith(SmartRunner.class) @SmartRunnerParameters(mockJVMNonDeterminism = true, useVNET = true, resetStaticState = true) 
public class ClientDefaultAccessTokenConverter_SSTest extends ClientDefaultAccessTokenConverter_SSTest_scaffolding {
// allCoveredLines:[24, 27, 36, 37, 45, 46, 49, 50, 52, 53, 56, 57, 58, 62, 63, 64, 68, 69, 71, 72, 75, 76, 79, 80, 83, 85, 86, 87, 90, 94, 95, 96, 97, 98, 99, 100, 101, 103, 104, 106, 107, 108, 112, 113, 114, 115, 116, 117, 118, 120, 121, 123, 124, 126, 130, 131, 144, 146, 150, 151, 156, 160, 161, 162, 163, 164, 165, 167, 168, 171]

  @Test(timeout = 9000)
  public void test_convertAccessToken_00()  throws Throwable  {
      //caseID:2c8bf30a44c7ea39b682dcf4e5c4be53
      //CoveredLines: [24, 27, 49, 50, 52, 62, 68, 71, 75, 79, 80, 83, 85, 86, 90]
      //Input_0_OAuth2AccessToken: {getExpiration=(Date) null, getScope=(Set<String>) null, getAdditionalInformation=map1 map0}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1 oAuth2Request2, isClientOnly=true}
      //Assert: assertEquals(2, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(0).when(map0).size();
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false).when(map1).containsKey(any());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map1, map0).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Date) null).when(oAuth2AccessToken0).getExpiration();
      doReturn((Set<String>) null).when(oAuth2AccessToken0).getScope();
      SynchronousQueue<GrantedAuthority> synchronousQueue0 = new SynchronousQueue<GrantedAuthority>();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("r.N*q'~$7j=9{K^").when(oAuth2Request0).getClientId();
      doReturn(synchronousQueue0, synchronousQueue0).when(oAuth2Request0).getAuthorities();
      doReturn((Set<String>) null).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("com.wanxin.uaa.domain.ClientDefaultAccessTokenConverter").when(oAuth2Request1).getGrantType();
      //mock oAuth2Request2
      OAuth2Request oAuth2Request2 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn((String) null).when(oAuth2Request2).getGrantType();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1, oAuth2Request2).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(2, map2.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_01()  throws Throwable  {
      //caseID:571e7b644455b576b9fb7726d528970a
      //CoveredLines: [24, 27, 49, 50, 52, 53, 56, 68, 71, 75, 79, 83, 85, 86, 90]
      //Input_0_OAuth2AccessToken: {getScope=(Set<String>) null, getAdditionalInformation=map0}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1, getUserAuthentication=authentication0, isClientOnly=false}
      //Assert: assertEquals(2, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Set<String>) null).when(oAuth2AccessToken0).getScope();
      //mock authentication0
      Authentication authentication0 = mock(Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn((Collection<GrantedAuthority>) null).when(oAuth2Request0).getAuthorities();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(authentication0).when(oAuth2Authentication0).getUserAuthentication();
      doReturn(false).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map1 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(2, map1.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_02()  throws Throwable  {
      //caseID:2edb58d3842891f2e4b8064e432716bf
      //CoveredLines: [24, 27, 49, 50, 52, 62, 63, 64, 68, 71, 75, 79, 83, 85, 86, 90]
      //Input_0_OAuth2AccessToken: {getScope=(Set<String>) null, getAdditionalInformation=map0}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0, isClientOnly=true}
      //Assert: assertEquals(2, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Set<String>) null).when(oAuth2AccessToken0).getScope();
      PriorityQueue<GrantedAuthority> priorityQueue0 = new PriorityQueue<GrantedAuthority>();
      //mock grantedAuthority0
      GrantedAuthority grantedAuthority0 = mock(GrantedAuthority.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      priorityQueue0.add(grantedAuthority0);
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(priorityQueue0).when(oAuth2Request0).getAuthorities();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map1 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(2, map1.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_03()  throws Throwable  {
      //caseID:c96dfe8a2cb5674a00ed5ef0c449ca09
      //CoveredLines: [24, 27, 49, 50, 52, 62, 63, 64, 68, 69, 71, 75, 79, 83, 85, 86, 90]
      //Input_0_OAuth2AccessToken: {getScope=linkedHashSet0, getAdditionalInformation=map0}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0, isClientOnly=true}
      //Assert: assertEquals(3, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn(linkedHashSet0).when(oAuth2AccessToken0).getScope();
      PriorityQueue<GrantedAuthority> priorityQueue0 = new PriorityQueue<GrantedAuthority>();
      //mock grantedAuthority0
      GrantedAuthority grantedAuthority0 = mock(GrantedAuthority.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      priorityQueue0.add(grantedAuthority0);
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(priorityQueue0).when(oAuth2Request0).getAuthorities();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map1 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(3, map1.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_04()  throws Throwable  {
      //caseID:450d9bd94b93b77117446b4ae7f435eb
      //CoveredLines: [24, 27, 49, 50, 52, 62, 68, 69, 71, 75, 79, 80, 83, 85, 86, 87, 90]
      //Input_0_OAuth2AccessToken: {getExpiration=(Date) null, getScope=linkedHashSet0 linkedHashSet0, getAdditionalInformation=map0 map1}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1, isClientOnly=true}
      //Assert: assertEquals(4, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false).when(map0).containsKey(any());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      
      linkedHashSet0.add("fsE[5Jm");
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(0).when(map1).size();
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, map1).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Date) null).when(oAuth2AccessToken0).getExpiration();
      doReturn(linkedHashSet0, linkedHashSet0).when(oAuth2AccessToken0).getScope();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("1.0").when(oAuth2Request0).getClientId();
      doReturn((Collection<GrantedAuthority>) null).when(oAuth2Request0).getAuthorities();
      doReturn(linkedHashSet0, linkedHashSet0, linkedHashSet0).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("1.0").when(oAuth2Request1).getGrantType();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(4, map2.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_05()  throws Throwable  {
      //caseID:5eb8156ff46a8b3e20767c4f0127ae92
      //CoveredLines: [24, 27, 49, 50, 52, 62, 68, 69, 71, 72, 75, 79, 83, 85, 86, 87, 90]
      //Input_0_OAuth2AccessToken: {getExpiration=(Date) null, getScope=linkedHashSet0 linkedHashSet0, getAdditionalInformation=map0 map1}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1, isClientOnly=true}
      //Assert: assertEquals(4, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      
      linkedHashSet0.add("fsE[5Jm");
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(0).when(map1).size();
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, map1).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Date) null).when(oAuth2AccessToken0).getExpiration();
      doReturn(linkedHashSet0, linkedHashSet0).when(oAuth2AccessToken0).getScope();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("1.0").when(oAuth2Request0).getClientId();
      doReturn((Collection<GrantedAuthority>) null).when(oAuth2Request0).getAuthorities();
      doReturn(linkedHashSet0, linkedHashSet0, linkedHashSet0).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn((String) null).when(oAuth2Request1).getGrantType();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(4, map2.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_06()  throws Throwable  {
      //caseID:e78d4eae1d331fac05a799f28dd7c42e
      //CoveredLines: [24, 27, 49, 50, 52, 62, 63, 64, 68, 69, 71, 72, 75, 76, 79, 83, 85, 86, 90]
      //Input_0_OAuth2AccessToken: {getExpiration=date0, getScope=hashSet0 hashSet0, getAdditionalInformation=map0 map1}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1, isClientOnly=true}
      //Assert: assertEquals(5, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      HashSet<String> hashSet0 = new HashSet<String>();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      doReturn(251).when(map0).size();
      //mock date0
      Date date0 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, map1).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn(date0).when(oAuth2AccessToken0).getExpiration();
      doReturn(hashSet0, hashSet0).when(oAuth2AccessToken0).getScope();
      LinkedList<GrantedAuthority> linkedList0 = new LinkedList<GrantedAuthority>();
      //mock grantedAuthority0
      GrantedAuthority grantedAuthority0 = mock(GrantedAuthority.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("authorities").when(grantedAuthority0).getAuthority();
      
      linkedList0.add(grantedAuthority0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("tenant_id").when(oAuth2Request0).getClientId();
      doReturn(linkedList0, linkedList0, linkedList0).when(oAuth2Request0).getAuthorities();
      doReturn((String) null).when(oAuth2Request0).getGrantType();
      doReturn(treeSet0).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(5, map2.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_07()  throws Throwable  {
      //caseID:a53e723283390ab3fa8e3200079475de
      //CoveredLines: [24, 27, 49, 50, 52, 62, 63, 64, 68, 69, 71, 75, 76, 79, 83, 85, 86, 87, 90]
      //Input_0_OAuth2AccessToken: {getExpiration=date0 date1, getScope=treeSet0 treeSet0, getAdditionalInformation=map0 map1}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0, isClientOnly=true}
      //Assert: assertEquals(5, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false).when(map0).containsKey(any());
      TreeSet<String> treeSet0 = new TreeSet<String>();
      
      treeSet0.add(" ");
      //mock date0
      Date date0 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(0).when(map1).size();
      //mock date1
      Date date1 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(0L).when(date1).getTime();
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, map1).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn(date0, date1).when(oAuth2AccessToken0).getExpiration();
      doReturn(treeSet0, treeSet0).when(oAuth2AccessToken0).getScope();
      Stack<GrantedAuthority> stack0 = new Stack<GrantedAuthority>();
      //mock grantedAuthority0
      GrantedAuthority grantedAuthority0 = mock(GrantedAuthority.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("$w0v").when(grantedAuthority0).getAuthority();
      
      stack0.add(grantedAuthority0);
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(" ").when(oAuth2Request0).getClientId();
      doReturn(stack0, stack0, stack0).when(oAuth2Request0).getAuthorities();
      doReturn(treeSet0, treeSet0, treeSet0).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(5, map2.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_08()  throws Throwable  {
      //caseID:96a8229b201fa723fd8816112bcbfa11
      //CoveredLines: [24, 27, 49, 50, 52, 53, 56, 57, 58, 68, 69, 71, 72, 75, 76, 79, 83, 85, 86, 87, 90]
      //Input_0_OAuth2AccessToken: {getExpiration=date0, getScope=treeSet0 treeSet0, getAdditionalInformation=map0 map1}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1, getUserAuthentication=oAuth2Authentication0, isClientOnly=false}
      //Assert: assertEquals(7, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      TreeSet<String> treeSet0 = new TreeSet<String>();
      
      treeSet0.add("u");
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      doReturn((-1)).when(map0).size();
      //mock date0
      Date date0 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, map1).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn(date0).when(oAuth2AccessToken0).getExpiration();
      doReturn(treeSet0, treeSet0).when(oAuth2AccessToken0).getScope();
      LinkedTransferQueue<GrantedAuthority> linkedTransferQueue0 = new LinkedTransferQueue<GrantedAuthority>();
      //mock grantedAuthority0
      GrantedAuthority grantedAuthority0 = mock(GrantedAuthority.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      linkedTransferQueue0.add(grantedAuthority0);
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("reactor.core.publisher.FluxElapsed$ElapsedSubscriber").when(oAuth2Request0).getClientId();
      doReturn(treeSet0).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(linkedTransferQueue0).when(oAuth2Request1).getAuthorities();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Authentication1
      OAuth2Authentication oAuth2Authentication1 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1).when(oAuth2Authentication1).getOAuth2Request();
      doReturn(oAuth2Authentication0).when(oAuth2Authentication1).getUserAuthentication();
      doReturn(false).when(oAuth2Authentication1).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication1);
      
      //Test Result Assert
      assertEquals(7, map2.size());
  }

  @Test(timeout = 9000)
  public void test_extractAccessToken_09()  throws Throwable  {
      //caseID:bfd57e95e944af5859f16cfdc909c18d
      //CoveredLines: [24, 27, 94, 95, 96, 97, 98, 99, 100, 101]
      //Input_0_String: Failed to apply the value function for the gauge '
      //Input_1_Map<String, ?>: {size=0, containsKey=true, get=\"org.bouncycastle.jce.provider.BrokenJCEBlockCipher$BrokePBEWithMD5AndDES\"}
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, String> map0 = (Map<String, String>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      doReturn("org.bouncycastle.jce.provider.BrokenJCEBlockCipher$BrokePBEWithMD5AndDES").when(map0).get(any());
      doReturn(0).when(map0).size();
      
      //Call method: extractAccessToken
      // Undeclared exception!
      try { 
        clientDefaultAccessTokenConverter0.extractAccessToken("Failed to apply the value function for the gauge '", map0);
      } catch(Throwable e) {
         verifyException("com.wanxin.uaa.domain.ClientDefaultAccessTokenConverter", e);
         assertEquals("java.lang.ClassCastException", e.getClass().getName());
         assertEquals("java.lang.String cannot be cast to java.lang.Long", e.getMessage());
      }
  }

  @Test(timeout = 9000)
  public void test_extractAccessToken_10()  throws Throwable  {
      //caseID:a3003a8eb0f68cd500b7f16f23c1f986
      //CoveredLines: [24, 27, 94, 95, 96, 97, 98, 99, 100, 103, 104, 106, 107, 108, 160, 161, 162, 163, 164, 171]
      //Input_0_String: 1.0
      //Input_1_Map<String, ?>: {size=(-1), containsKey=false true true, get=\"mobile\" \"=\\\"\"}
      //Assert: assertEquals("bearer", method_result.getTokenType());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, String> map0 = (Map<String, String>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false, true, true).when(map0).containsKey(any());
      doReturn("mobile", "=\"").when(map0).get(any());
      doReturn((-1)).when(map0).size();
      
      //Call method: extractAccessToken
      OAuth2AccessToken oAuth2AccessToken0 = clientDefaultAccessTokenConverter0.extractAccessToken("1.0", map0);
      
      //Test Result Assert
      assertEquals("bearer", oAuth2AccessToken0.getTokenType());
  }

  @Test(timeout = 9000)
  public void test_extractAccessToken_11()  throws Throwable  {
      //caseID:fa830b166ea872f17491301091af3788
      //CoveredLines: [24, 27, 94, 95, 96, 97, 98, 99, 100, 103, 106, 107, 108, 160, 161, 162, 163, 165, 167, 168, 171]
      //Input_0_String: C^jv;jZDQaQDnVr
      //Input_1_Map<String, ?>: {size=(-1), containsKey=false false true, get=vector0}
      //Assert: assertEquals("bearer", method_result.getTokenType());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      Vector<Integer> vector0 = new Vector<Integer>();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false, false, true).when(map0).containsKey(any());
      doReturn(vector0).when(map0).get(any());
      doReturn((-1)).when(map0).size();
      
      //Call method: extractAccessToken
      OAuth2AccessToken oAuth2AccessToken0 = clientDefaultAccessTokenConverter0.extractAccessToken("C^jv;jZDQaQDnVr", map0);
      
      //Test Result Assert
      assertEquals("bearer", oAuth2AccessToken0.getTokenType());
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_12()  throws Throwable  {
      //caseID:cbab06766c425bd265d7d041840f8418
      //CoveredLines: [24, 27, 112, 113, 114, 115, 160, 161, 162, 163, 165, 171]
      //Input_0_Map<String, ?>: {containsKey=true, get=JLayeredPane.PALETTE_LAYER JLayeredPane.PALETTE_LAYER}
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock userAuthenticationConverter0
      UserAuthenticationConverter userAuthenticationConverter0 = mock(UserAuthenticationConverter.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Authentication0).when(userAuthenticationConverter0).extractAuthentication(ArgumentMatchers.<java.lang.String,Object>anyMap());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "userTokenConverter", (Object) userAuthenticationConverter0);
      Integer integer0 = JLayeredPane.PALETTE_LAYER;
      //mock map0
      Map<String, Integer> map0 = (Map<String, Integer>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      doReturn(integer0, integer0).when(map0).get(any());
      
      //Call method: extractAuthentication
      // Undeclared exception!
      try { 
        clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      } catch(Throwable e) {
         verifyException("com.wanxin.uaa.domain.ClientDefaultAccessTokenConverter", e);
         assertEquals("java.lang.ClassCastException", e.getClass().getName());
         assertEquals("java.lang.Integer cannot be cast to java.lang.String", e.getMessage());
      }
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_13()  throws Throwable  {
      //caseID:59b4a99b6cb953dccc2def5d87ce2ae2
      //CoveredLines: [24, 27, 112, 113, 114, 115, 116, 117, 120, 123, 124, 126, 150, 151, 156, 160, 161, 171]
      //Input_0_Map<String, ?>: {containsKey=false true true, get=\"0\" \"DwU/mV+5F)7x<ZTt\" \", predicate=\"}
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock userAuthenticationConverter0
      UserAuthenticationConverter userAuthenticationConverter0 = mock(UserAuthenticationConverter.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn((Authentication) null).when(userAuthenticationConverter0).extractAuthentication(ArgumentMatchers.<java.lang.String,Object>anyMap());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "userTokenConverter", (Object) userAuthenticationConverter0);
      //mock map0
      Map<String, String> map0 = (Map<String, String>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false, true, true).when(map0).containsKey(any());
      doReturn("0", "DwU/mV+5F)7x<ZTt", ", predicate=").when(map0).get(any());
      
      //Call method: extractAuthentication
      // Undeclared exception!
      try { 
        clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      } catch(Throwable e) {
         verifyException("com.wanxin.uaa.domain.ClientDefaultAccessTokenConverter", e);
         assertEquals("java.lang.ClassCastException", e.getClass().getName());
         assertEquals("java.lang.String cannot be cast to java.util.Collection", e.getMessage());
      }
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_14()  throws Throwable  {
      //caseID:4381befa4369082670c50248973db2d6
      //CoveredLines: [24, 27, 112, 113, 114, 115, 116, 117, 120, 123, 124, 130, 131, 150, 151, 156, 160, 161, 171]
      //Input_0_Map<String, ?>: {containsKey=false true true, get=\"WebApplicationContext\" \"client_id\" \"-1\"}
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, String> map0 = (Map<String, String>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false, true, true).when(map0).containsKey(any());
      doReturn("WebApplicationContext", "client_id", "-1").when(map0).get(any());
      
      //Call method: extractAuthentication
      // Undeclared exception!
      try { 
        clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      } catch(Throwable e) {
         verifyException("com.wanxin.uaa.domain.ClientDefaultAccessTokenConverter", e);
         assertEquals("java.lang.ClassCastException", e.getClass().getName());
         assertEquals("java.lang.String cannot be cast to java.util.Collection", e.getMessage());
      }
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_15()  throws Throwable  {
      //caseID:eb463063bae67a9d9382ee012cdda695
      //CoveredLines: [24, 27, 112, 113, 114, 115, 116, 117, 120, 121, 123, 124, 130, 144, 146, 160, 161, 171]
      //Input_0_Map<String, ?>: {}
      //Assert: assertTrue(method_result.isAuthenticated());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock map0
      Map<String, String> map0 = (Map<String, String>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      //Call method: extractAuthentication
      OAuth2Authentication oAuth2Authentication0 = clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      
      //Test Result Assert
      assertTrue(oAuth2Authentication0.isAuthenticated());
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_16()  throws Throwable  {
      //caseID:4fb75ec7833de9ba6418ccd26c2dd9d2
      //CoveredLines: [24, 27, 112, 113, 114, 115, 116, 117, 118, 120, 121, 123, 124, 130, 144, 146, 160, 161, 171]
      //Input_0_Map<String, ?>: {containsKey=false true false, get=\"count must be greater than 0\"}
      //Assert: assertFalse(method_result.isAuthenticated());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock userAuthenticationConverter0
      UserAuthenticationConverter userAuthenticationConverter0 = mock(UserAuthenticationConverter.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Authentication0).when(userAuthenticationConverter0).extractAuthentication(ArgumentMatchers.<java.lang.String,Object>anyMap());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "userTokenConverter", (Object) userAuthenticationConverter0);
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock map0
      Map<String, String> map0 = (Map<String, String>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false, true, false).when(map0).containsKey(any());
      doReturn("count must be greater than 0").when(map0).get(any());
      
      //Call method: extractAuthentication
      OAuth2Authentication oAuth2Authentication1 = clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      
      //Test Result Assert
      assertFalse(oAuth2Authentication1.isAuthenticated());
  }

  @Test(timeout = 9000)
  public void test_setIncludeGrantType_17()  throws Throwable  {
      //caseID:08959979a5aa6805eb91d75a2f471930
      //CoveredLines: [24, 27, 45, 46]
      //Input_0_boolean: false
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      //Call method: setIncludeGrantType
      clientDefaultAccessTokenConverter0.setIncludeGrantType(false);
  }

  @Test(timeout = 9000)
  public void test_setUserTokenConverter_18()  throws Throwable  {
      //caseID:58f97ca67565c3da83caef778e35eb92
      //CoveredLines: [24, 27, 36, 37]
      //Input_0_UserAuthenticationConverter: {}
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock userAuthenticationConverter0
      UserAuthenticationConverter userAuthenticationConverter0 = mock(UserAuthenticationConverter.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      //Call method: setUserTokenConverter
      clientDefaultAccessTokenConverter0.setUserTokenConverter(userAuthenticationConverter0);
  }
}
