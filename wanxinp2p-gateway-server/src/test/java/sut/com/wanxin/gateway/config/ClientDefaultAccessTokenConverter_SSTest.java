/*
 * This file was automatically generated by SmartUnit
 */

package sut.com.wanxin.gateway.config;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Method;
import static org.smartunit.shaded.org.mockito.Mockito.*;
import org.smartunit.shaded.org.mockito.ArgumentMatchers;
import static org.smartunit.runtime.SmartAssertions.*;
import com.wanxin.gateway.config.ClientDefaultAccessTokenConverter;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedTransferQueue;
import org.junit.runner.RunWith;
import org.smartunit.runtime.ExecutorServiceAnswer;
import org.smartunit.runtime.PrivateAccess;
import org.smartunit.runtime.SmartRunner;
import org.smartunit.runtime.SmartRunnerParameters;
import org.smartunit.runtime.TransactionTemplateAnswer;
import org.smartunit.runtime.ViolatedAssumptionAnswer;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;
import org.springframework.security.oauth2.provider.token.UserAuthenticationConverter;

@RunWith(SmartRunner.class) @SmartRunnerParameters(mockJVMNonDeterminism = true, useVNET = true, resetStaticState = true) 
public class ClientDefaultAccessTokenConverter_SSTest extends ClientDefaultAccessTokenConverter_SSTest_scaffolding {
// allCoveredLines:[25, 28, 37, 38, 46, 47, 51, 52, 54, 55, 58, 59, 60, 64, 65, 66, 70, 71, 73, 74, 77, 78, 81, 82, 85, 87, 88, 89, 92, 97, 98, 99, 100, 101, 102, 103, 104, 106, 107, 109, 110, 111, 116, 117, 118, 119, 120, 121, 122, 124, 125, 127, 128, 134, 135, 136, 138, 139, 140, 141, 142, 147, 149, 153, 154, 159, 163, 164, 165, 166, 167, 168, 170, 172, 175]

  @Test(timeout = 9000)
  public void test_convertAccessToken_00()  throws Throwable  {
      //caseID:2a0277e16f507f79a6c758f7059013fc
      //CoveredLines: [25, 28, 51, 52, 54, 55, 58, 59, 60, 70, 71, 73, 77, 78, 81, 85, 87, 88, 92]
      //Input_0_OAuth2AccessToken: {getExpiration=date0 date1, getScope=linkedHashSet0 linkedHashSet0, getAdditionalInformation=hashMap0 hashMap0}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1 oAuth2Request2 oAuth2Request3 oAuth2Request4, getUserAuthentication=oAuth2Authentication0, isClientOnly=false}
      //Assert: assertEquals(5, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      HashMap<String, Object> hashMap0 = new HashMap<String, Object>();
      //mock date0
      Date date0 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock date1
      Date date1 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(0L).when(date1).getTime();
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(hashMap0, hashMap0).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn(date0, date1).when(oAuth2AccessToken0).getExpiration();
      doReturn(linkedHashSet0, linkedHashSet0).when(oAuth2AccessToken0).getScope();
      LinkedTransferQueue<GrantedAuthority> linkedTransferQueue0 = new LinkedTransferQueue<GrantedAuthority>();
      //mock grantedAuthority0
      GrantedAuthority grantedAuthority0 = mock(GrantedAuthority.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("T").when(grantedAuthority0).getAuthority();
      
      linkedTransferQueue0.add(grantedAuthority0);
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(linkedTransferQueue0).when(oAuth2Request1).getAuthorities();
      //mock oAuth2Request2
      OAuth2Request oAuth2Request2 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(linkedTransferQueue0).when(oAuth2Request2).getAuthorities();
      //mock oAuth2Request3
      OAuth2Request oAuth2Request3 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(linkedTransferQueue0).when(oAuth2Request3).getAuthorities();
      //mock oAuth2Request4
      OAuth2Request oAuth2Request4 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn((String) null).when(oAuth2Request4).getGrantType();
      //mock oAuth2Authentication1
      OAuth2Authentication oAuth2Authentication1 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1, oAuth2Request2, oAuth2Request3, oAuth2Request4).when(oAuth2Authentication1).getOAuth2Request();
      doReturn(oAuth2Authentication0).when(oAuth2Authentication1).getUserAuthentication();
      doReturn(false).when(oAuth2Authentication1).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map0 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication1);
      
      //Test Result Assert
      assertEquals(5, map0.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_01()  throws Throwable  {
      //caseID:1ad39c2b3f47973d90ec7a8ac3189de3
      //CoveredLines: [25, 28, 51, 52, 54, 64, 70, 73, 77, 81, 85, 87, 88, 92]
      //Input_0_OAuth2AccessToken: {getScope=(Set<String>) null, getAdditionalInformation=map0}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0, isClientOnly=true}
      //Assert: assertEquals(1, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Set<String>) null).when(oAuth2AccessToken0).getScope();
      LinkedList<GrantedAuthority> linkedList0 = new LinkedList<GrantedAuthority>();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(linkedList0).when(oAuth2Request0).getAuthorities();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map1 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(1, map1.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_02()  throws Throwable  {
      //caseID:50136081756898f1b09da3a3734067aa
      //CoveredLines: [25, 28, 51, 52, 54, 64, 70, 71, 73, 77, 81, 85, 87, 88, 92]
      //Input_0_OAuth2AccessToken: {getExpiration=(Date) null, getScope=linkedHashSet0 linkedHashSet0, getAdditionalInformation=map0 map1}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1, isClientOnly=true}
      //Assert: assertEquals(2, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false).when(map0).containsKey(any());
      doReturn((-1)).when(map0).size();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, map1).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Date) null).when(oAuth2AccessToken0).getExpiration();
      doReturn(linkedHashSet0, linkedHashSet0).when(oAuth2AccessToken0).getScope();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("client_authorities").when(oAuth2Request0).getClientId();
      doReturn((Collection<GrantedAuthority>) null).when(oAuth2Request0).getAuthorities();
      doReturn((String) null).when(oAuth2Request0).getGrantType();
      doReturn(linkedHashSet0).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(2, map2.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_03()  throws Throwable  {
      //caseID:a8d67df1a9f36f1a828ed6eabbffc400
      //CoveredLines: [25, 28, 51, 52, 54, 64, 65, 66, 70, 73, 77, 81, 85, 87, 88, 92]
      //Input_0_OAuth2AccessToken: {getScope=(Set<String>) null, getAdditionalInformation=map0}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0, isClientOnly=true}
      //Assert: assertEquals(2, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Set<String>) null).when(oAuth2AccessToken0).getScope();
      LinkedBlockingDeque<GrantedAuthority> linkedBlockingDeque0 = new LinkedBlockingDeque<GrantedAuthority>();
      //mock grantedAuthority0
      GrantedAuthority grantedAuthority0 = mock(GrantedAuthority.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      linkedBlockingDeque0.add(grantedAuthority0);
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(linkedBlockingDeque0).when(oAuth2Request0).getAuthorities();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map1 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(2, map1.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_04()  throws Throwable  {
      //caseID:a738766d02d1e574f52de3b972e7ef2d
      //CoveredLines: [25, 28, 51, 52, 54, 55, 58, 70, 73, 74, 77, 78, 81, 85, 87, 88, 92]
      //Input_0_OAuth2AccessToken: {getExpiration=date0, getScope=(Set<String>) null, getAdditionalInformation=map0 map1}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1 oAuth2Request2 oAuth2Request3, getUserAuthentication=oAuth2Authentication0, isClientOnly=false}
      //Assert: assertEquals(4, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      doReturn(3300).when(map0).size();
      //mock date0
      Date date0 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, map1).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn(date0).when(oAuth2AccessToken0).getExpiration();
      doReturn((Set<String>) null).when(oAuth2AccessToken0).getScope();
      LinkedTransferQueue<GrantedAuthority> linkedTransferQueue0 = new LinkedTransferQueue<GrantedAuthority>();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("org.bouncycastle.jcajce.provider.asymmetric.dh.KeyFactorySpi").when(oAuth2Request0).getClientId();
      doReturn((Set<String>) null).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(linkedTransferQueue0).when(oAuth2Request1).getAuthorities();
      //mock oAuth2Request2
      OAuth2Request oAuth2Request2 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(linkedTransferQueue0).when(oAuth2Request2).getAuthorities();
      //mock oAuth2Request3
      OAuth2Request oAuth2Request3 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn((String) null).when(oAuth2Request3).getGrantType();
      //mock oAuth2Authentication1
      OAuth2Authentication oAuth2Authentication1 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1, oAuth2Request2, oAuth2Request3).when(oAuth2Authentication1).getOAuth2Request();
      doReturn(oAuth2Authentication0).when(oAuth2Authentication1).getUserAuthentication();
      doReturn(false).when(oAuth2Authentication1).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication1);
      
      //Test Result Assert
      assertEquals(4, map2.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_05()  throws Throwable  {
      //caseID:370c797e17c7f7bdabcb2239aae6fa75
      //CoveredLines: [25, 28, 51, 52, 54, 64, 70, 73, 74, 77, 78, 81, 82, 85, 87, 88, 92]
      //Input_0_OAuth2AccessToken: {getExpiration=date0 date1, getScope=(Set<String>) null, getAdditionalInformation=map0 hashMap0 hashMap0}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1 oAuth2Request2, isClientOnly=true}
      //Assert: assertEquals(4, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock date0
      Date date0 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      HashMap<String, Object> hashMap0 = new HashMap<String, Object>();
      //mock date1
      Date date1 = mock(Date.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(1233L).when(date1).getTime();
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, hashMap0, hashMap0).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn(date0, date1).when(oAuth2AccessToken0).getExpiration();
      doReturn((Set<String>) null).when(oAuth2AccessToken0).getScope();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("client_authorities").when(oAuth2Request0).getClientId();
      doReturn((Collection<GrantedAuthority>) null).when(oAuth2Request0).getAuthorities();
      doReturn((Set<String>) null).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(" ").when(oAuth2Request1).getGrantType();
      //mock oAuth2Request2
      OAuth2Request oAuth2Request2 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("-2").when(oAuth2Request2).getGrantType();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1, oAuth2Request2).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map1 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(4, map1.size());
  }

  @Test(timeout = 9000)
  public void test_convertAccessToken_06()  throws Throwable  {
      //caseID:55093d02fda733c7931dc2c0b285ef1e
      //CoveredLines: [25, 28, 51, 52, 54, 64, 70, 71, 73, 74, 77, 81, 85, 87, 88, 89, 92]
      //Input_0_OAuth2AccessToken: {getExpiration=(Date) null, getScope=hashSet0 hashSet0, getAdditionalInformation=map0 map1}
      //Input_1_OAuth2Authentication: {getOAuth2Request=oAuth2Request0 oAuth2Request1, isClientOnly=true}
      //Assert: assertEquals(4, method_result.size());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      doReturn(0).when(map0).size();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      HashSet<String> hashSet0 = new HashSet<String>();
      //mock map1
      Map<String, Object> map1 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2AccessToken0
      OAuth2AccessToken oAuth2AccessToken0 = mock(OAuth2AccessToken.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(map0, map1).when(oAuth2AccessToken0).getAdditionalInformation();
      doReturn((Date) null).when(oAuth2AccessToken0).getExpiration();
      doReturn(hashSet0, hashSet0).when(oAuth2AccessToken0).getScope();
      
      hashSet0.add("0");
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn("2147483645").when(oAuth2Request0).getClientId();
      doReturn((Collection<GrantedAuthority>) null).when(oAuth2Request0).getAuthorities();
      doReturn("user_authorities").when(oAuth2Request0).getGrantType();
      doReturn(hashSet0).when(oAuth2Request0).getResourceIds();
      //mock oAuth2Request1
      OAuth2Request oAuth2Request1 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Request0, oAuth2Request1).when(oAuth2Authentication0).getOAuth2Request();
      doReturn(true).when(oAuth2Authentication0).isClientOnly();
      
      //Call method: convertAccessToken
      Map<String, ?> map2 = clientDefaultAccessTokenConverter0.convertAccessToken(oAuth2AccessToken0, oAuth2Authentication0);
      
      //Test Result Assert
      assertEquals(4, map2.size());
  }

  @Test(timeout = 9000)
  public void test_extractAccessToken_07()  throws Throwable  {
      //caseID:786ff72d6953c5ad1bfd21fb4eacc3d4
      //CoveredLines: [25, 28, 97, 98, 99, 100, 101, 102, 103, 106, 109, 110, 111, 163, 164, 175]
      //Input_0_String: 0
      //Input_1_Map<String, ?>: {}
      //Assert: assertEquals("bearer", method_result.getTokenType());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, String> map0 = (Map<String, String>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      //Call method: extractAccessToken
      OAuth2AccessToken oAuth2AccessToken0 = clientDefaultAccessTokenConverter0.extractAccessToken("0", map0);
      
      //Test Result Assert
      assertEquals("bearer", oAuth2AccessToken0.getTokenType());
  }

  @Test(timeout = 9000)
  public void test_extractAccessToken_08()  throws Throwable  {
      //caseID:d8880c485ee5429fccfcd4e5d3e41fca
      //CoveredLines: [25, 28, 97, 98, 99, 100, 101, 102, 103, 106, 107, 109, 110, 111, 163, 164, 175]
      //Input_0_String: 
      //Input_1_Map<String, ?>: {size=(-1), containsKey=false true false}
      //Assert: assertEquals("", method_result.getValue());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false, true, false).when(map0).containsKey(any());
      doReturn((-1)).when(map0).size();
      
      //Call method: extractAccessToken
      OAuth2AccessToken oAuth2AccessToken0 = clientDefaultAccessTokenConverter0.extractAccessToken("", map0);
      
      //Test Result Assert
      assertEquals("", oAuth2AccessToken0.getValue());
  }

  @Test(timeout = 9000)
  public void test_extractAccessToken_09()  throws Throwable  {
      //caseID:faee8db9fb41d7ede45eedc02adcf313
      //CoveredLines: [25, 28, 97, 98, 99, 100, 101, 102, 103, 104, 106, 107, 109, 110, 111, 163, 164, 165, 166, 168, 175]
      //Input_0_String: scope
      //Input_1_Map<String, ?>: {size=(-1), containsKey=true true true, get=(-1) (-1) (-1)}
      //Assert: assertEquals("scope", method_result.getValue());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      Long long0 = new Long((-1));
      //mock map0
      Map<String, Long> map0 = (Map<String, Long>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true, true, true).when(map0).containsKey(any());
      doReturn(long0, long0, long0).when(map0).get(any());
      doReturn((-1)).when(map0).size();
      
      //Call method: extractAccessToken
      OAuth2AccessToken oAuth2AccessToken0 = clientDefaultAccessTokenConverter0.extractAccessToken("scope", map0);
      
      //Test Result Assert
      assertEquals("scope", oAuth2AccessToken0.getValue());
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_10()  throws Throwable  {
      //caseID:9ff16f34b99ece6b3fb07ba27e582f60
      //CoveredLines: [25, 28, 116, 117, 118, 119, 120, 121, 122, 124, 125, 127, 128, 134, 135, 163, 164, 165, 166, 167, 175]
      //Input_0_Map<String, ?>: {containsKey=true true false true, get=\"bufferSize must be a power of 2 : \" \"i$C(#\" \"exp\" \"rx.internal.operators.OperatorUnsubscribeOn\"}
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock userAuthenticationConverter0
      UserAuthenticationConverter userAuthenticationConverter0 = mock(UserAuthenticationConverter.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Authentication0).when(userAuthenticationConverter0).extractAuthentication(ArgumentMatchers.<java.lang.String,Object>anyMap());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "userTokenConverter", (Object) userAuthenticationConverter0);
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock map0
      Map<String, String> map0 = (Map<String, String>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true, true, false, true).when(map0).containsKey(any());
      doReturn("bufferSize must be a power of 2 : ", "i$C(#", "exp", "rx.internal.operators.OperatorUnsubscribeOn").when(map0).get(any());
      
      //Call method: extractAuthentication
      // Undeclared exception!
      try { 
        clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      } catch(Throwable e) {
         verifyException("com.wanxin.gateway.config.ClientDefaultAccessTokenConverter", e);
         assertEquals("java.lang.ClassCastException", e.getClass().getName());
         assertEquals("java.lang.String cannot be cast to java.util.Collection", e.getMessage());
      }
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_11()  throws Throwable  {
      //caseID:45f81b633ad651a2961104803d7ec760
      //CoveredLines: [25, 28, 116, 117, 118, 119, 120, 121, 124, 125, 127, 128, 134, 147, 149, 163, 164, 175]
      //Input_0_Map<String, ?>: {}
      //Assert: assertTrue(method_result.isAuthenticated());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      //Call method: extractAuthentication
      OAuth2Authentication oAuth2Authentication0 = clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      
      //Test Result Assert
      assertTrue(oAuth2Authentication0.isAuthenticated());
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_12()  throws Throwable  {
      //caseID:4dd178e9749dcd38f7683e26b1837e7d
      //CoveredLines: [25, 28, 116, 117, 118, 119, 120, 121, 122, 124, 125, 127, 128, 134, 147, 149, 163, 164, 175]
      //Input_0_Map<String, ?>: {containsKey=false true false false, get=\"1.0\"}
      //Assert: assertFalse(method_result.isAuthenticated());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock oAuth2Authentication0
      OAuth2Authentication oAuth2Authentication0 = mock(OAuth2Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock userAuthenticationConverter0
      UserAuthenticationConverter userAuthenticationConverter0 = mock(UserAuthenticationConverter.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(oAuth2Authentication0).when(userAuthenticationConverter0).extractAuthentication(ArgumentMatchers.<java.lang.String,Object>anyMap());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "userTokenConverter", (Object) userAuthenticationConverter0);
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "includeGrantType", (Object) true);
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(false, true, false, false).when(map0).containsKey(any());
      doReturn("1.0").when(map0).get(any());
      
      //Call method: extractAuthentication
      OAuth2Authentication oAuth2Authentication1 = clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      
      //Test Result Assert
      assertFalse(oAuth2Authentication1.isAuthenticated());
  }

  @Test(timeout = 9000)
  public void test_extractAuthentication_13()  throws Throwable  {
      //caseID:82bab1391fd720c0a0a2f84b1d426a0f
      //CoveredLines: [25, 28, 116, 117, 118, 119, 120, 121, 124, 127, 128, 134, 135, 136, 138, 139, 140, 141, 142, 147, 149, 153, 154, 159, 163, 164, 165, 166, 168, 175]
      //Input_0_Map<String, ?>: {containsKey=true true true false, get=oAuth2Request0 \"jti\" \"not done yet\" linkedTransferQueue0 \"tenant_id\"}
      //Assert: assertFalse(method_result.isClientOnly());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock authentication0
      Authentication authentication0 = mock(Authentication.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock userAuthenticationConverter0
      UserAuthenticationConverter userAuthenticationConverter0 = mock(UserAuthenticationConverter.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(authentication0).when(userAuthenticationConverter0).extractAuthentication(ArgumentMatchers.<java.lang.String,Object>anyMap());
      
      PrivateAccess.setVariable((Class<?>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "userTokenConverter", (Object) userAuthenticationConverter0);
      LinkedTransferQueue<String> linkedTransferQueue0 = new LinkedTransferQueue<String>();
      //mock oAuth2Request0
      OAuth2Request oAuth2Request0 = mock(OAuth2Request.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true, true, true, false).when(map0).containsKey(any());
      doReturn(oAuth2Request0, "jti", "not done yet", linkedTransferQueue0, "tenant_id").when(map0).get(any());
      
      //Call method: extractAuthentication
      OAuth2Authentication oAuth2Authentication0 = clientDefaultAccessTokenConverter0.extractAuthentication(map0);
      
      //Test Result Assert
      assertFalse(oAuth2Authentication0.isClientOnly());
  }

  @Test(timeout = 9000)
  public void test_extractScope_14()  throws Throwable  {
      //caseID:ee14754cfa1342755798b108e8e395df
      //CoveredLines: [25, 28, 163, 164, 165, 166, 168, 170, 172, 175]
      //Input_0_Map<String, ?>: {containsKey=true, get=arrayDeque0}
      //Assert: assertTrue(method_result.isEmpty());
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      ArrayDeque<Collection<Object>> arrayDeque0 = new ArrayDeque<Collection<Object>>();
      //mock map0
      Map<String, Object> map0 = (Map<String, Object>) mock(Map.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      doReturn(true).when(map0).containsKey(any());
      doReturn(arrayDeque0).when(map0).get(any());
      
      //Call method: extractScope
      Set<String> set0 = (Set<String>)PrivateAccess.callMethod((Class<ClientDefaultAccessTokenConverter>) ClientDefaultAccessTokenConverter.class, clientDefaultAccessTokenConverter0, "extractScope", (Object) map0, (Class<?>) Map.class);
      
      //Test Result Assert
      assertTrue(set0.isEmpty());
  }

  @Test(timeout = 9000)
  public void test_setIncludeGrantType_15()  throws Throwable  {
      //caseID:1fede312c0ff456df7f5e2e981e3646d
      //CoveredLines: [25, 28, 46, 47]
      //Input_0_boolean: true
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      
      //Call method: setIncludeGrantType
      clientDefaultAccessTokenConverter0.setIncludeGrantType(true);
  }

  @Test(timeout = 9000)
  public void test_setUserTokenConverter_16()  throws Throwable  {
      //caseID:df9b321d995dc06715af6874ff8bbba9
      //CoveredLines: [25, 28, 37, 38]
      //Input_0_UserAuthenticationConverter: {}
      
      ClientDefaultAccessTokenConverter clientDefaultAccessTokenConverter0 = new ClientDefaultAccessTokenConverter();
      //mock userAuthenticationConverter0
      UserAuthenticationConverter userAuthenticationConverter0 = mock(UserAuthenticationConverter.class, withSettings().defaultAnswer(new ViolatedAssumptionAnswer()).stubOnly());
      
      //Call method: setUserTokenConverter
      clientDefaultAccessTokenConverter0.setUserTokenConverter(userAuthenticationConverter0);
  }
}
